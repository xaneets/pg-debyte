# pg-debyte

[![Build](https://github.com/Xaneets/pg-debyte/actions/workflows/build.yml/badge.svg)](https://github.com/Xaneets/pg-debyte/actions/workflows/build.yml)
[![Workspace tests](https://github.com/Xaneets/pg-debyte/actions/workflows/core-tests.yml/badge.svg)](https://github.com/Xaneets/pg-debyte/actions/workflows/core-tests.yml)
[![PG extension tests](https://github.com/Xaneets/pg-debyte/actions/workflows/pg-extension-tests.yml/badge.svg)](https://github.com/Xaneets/pg-debyte/actions/workflows/pg-extension-tests.yml)
[![Crates.io](https://img.shields.io/crates/v/pg_debyte_core.svg)](https://crates.io/crates/pg_debyte_core)

Core building blocks for PostgreSQL extensions that decode `bytea` into JSON.
This repository provides reusable Rust crates plus a small example extension.

## Workspace

- `pg_debyte_core`: envelope parser, registry, codecs/actions, limits, errors.
- `pg_debyte_macros`: helper macros for registering typed decoders.
- `pg_debyte_pgrx`: PG17-only helper glue (GUC limits and decoding helpers).
- `pg_debyte_ext`: example PG17 extension crate with a demo registry and decoder.
- `pg_debyte_tools`: helper binaries (demo payload generator).

## MVP status

- Envelope format parsing (magic + version + type_id + schema_version + codec + actions).
- Action pipeline (decode in reverse) with bounded zstd decode.
- Bincode codec with size limits.
- Static registry for decoders/codecs/actions.
- PG17-only helper for GUC limits and decoding (to be called from extension).

## Notes

- `pg_debyte_ext` is only an example implementation; you will create your own extension crate.
- PG15 support will be added later as a separate focus.

## Quick start: build your own extension

Common setup:

```bash
cargo new my_pg_debyte_ext --lib
cd my_pg_debyte_ext
```

```toml
[dependencies]
pgrx = { version = "0.16.1", default-features = false, features = ["pg17"] }
pg_debyte_core = "0.1.0"
pg_debyte_macros = "0.1.0"
pg_debyte_pgrx = "0.1.0"
serde = { version = "1.0", features = ["derive"] }
uuid = "1.8"
bincode = "1.3"
hex = "0.4"
```

Build and install once:

```bash
cargo pgrx init --pg17 /path/to/pg17
cargo pgrx install --features pg17 --sudo
```

Enable in Postgres:

```sql
CREATE EXTENSION my_pg_debyte_ext;
```

### Known schema (per-type function)

Use this when the payload schema is fixed and you want a dedicated SQL function per type.
The function is generated by `declare_know_schema!` and decodes raw payload without an envelope.

`src/lib.rs`:

```rust
use pgrx::prelude::*;
use pg_debyte_core::{BincodeCodec, StaticRegistry};
use pg_debyte_macros::declare_know_schema;
use serde::{Deserialize, Serialize};
use uuid::Uuid as CoreUuid;

pg_module_magic!();

#[derive(Debug, Deserialize, Serialize)]
struct MyRecord {
    id: u32,
    label: String,
}

const MY_TYPE_ID: CoreUuid = CoreUuid::from_bytes([0x22; 16]);
const MY_SCHEMA_VERSION: u16 = 1;
const MY_CODEC_ID: u16 = 1;
const MY_CODEC: BincodeCodec = BincodeCodec::new(MY_CODEC_ID, 32 * 1024 * 1024);

declare_know_schema!(
    MY_DECODER,
    ty = MyRecord,
    type_id = MY_TYPE_ID,
    schema_version = MY_SCHEMA_VERSION,
    codec = MY_CODEC,
    codec_ty = BincodeCodec,
    actions = [],
    fn_name = bytea_to_json_my_record
);

static REGISTRY: StaticRegistry = StaticRegistry::new(&[&MY_DECODER], &[]);

#[pg_guard]
pub unsafe extern "C-unwind" fn _PG_init() {
    pg_debyte_pgrx::init_gucs();
    pg_debyte_pgrx::set_registry(&REGISTRY);
}
```

Usage:


```sql
SELECT bytea_to_json_my_record(decode('<hex-encoded-payload>', 'hex'));
```

### Registry + by_id

Use this when you have raw payloads but need flexible routing by `type_id` + `schema_version`.
You register decoders in a registry and call a single SQL function with explicit type info.

`src/lib.rs`:

```rust
use pgrx::prelude::*;
use pgrx::JsonB;
use pg_debyte_core::{BincodeCodec, DecodeError, StaticRegistry};
use pg_debyte_macros::declare_decoder;
use serde::{Deserialize, Serialize};
use uuid::Uuid as CoreUuid;

pg_module_magic!();

#[derive(Debug, Deserialize, Serialize)]
struct MyRecord {
    id: u32,
    label: String,
}

const MY_TYPE_ID: CoreUuid = CoreUuid::from_bytes([0x22; 16]);
const MY_SCHEMA_VERSION: u16 = 1;
const MY_CODEC_ID: u16 = 1;
const MY_CODEC: BincodeCodec = BincodeCodec::new(MY_CODEC_ID, 32 * 1024 * 1024);

declare_decoder!(
    MY_DECODER,
    ty = MyRecord,
    type_id = MY_TYPE_ID,
    schema_version = MY_SCHEMA_VERSION,
    codec = MY_CODEC,
    codec_ty = BincodeCodec,
    actions = []
);

static REGISTRY: StaticRegistry = StaticRegistry::new(&[&MY_DECODER], &[]);

#[pg_guard]
pub unsafe extern "C-unwind" fn _PG_init() {
    pg_debyte_pgrx::init_gucs();
    pg_debyte_pgrx::set_registry(&REGISTRY);
}

#[pg_extern]
fn bytea_to_json_by_id(
    data: Vec<u8>,
    type_id: pgrx::Uuid,
    schema_version: i16,
) -> Result<JsonB, DecodeError> {
    let limits = pg_debyte_pgrx::limits();
    let core_uuid = CoreUuid::from_bytes(*type_id.as_bytes());
    let value = pg_debyte_pgrx::decode_by_id(&data, core_uuid, schema_version, &limits)?;
    Ok(JsonB(value))
}
```

Usage (reuse `demo_payload.rs` from above):

```sql
SELECT bytea_to_json_by_id(
  decode('<hex-encoded-payload>', 'hex'),
  '22222222-2222-2222-2222-222222222222'::uuid,
  1::smallint
);
```

### Envelope (auto)

Use this when payloads include an envelope with type, version, codec, and actions.
`bytea_to_json_auto` parses the envelope and dispatches to the matching decoder automatically.

`src/lib.rs`:

```rust
use pgrx::prelude::*;
use pgrx::JsonB;
use pg_debyte_core::{BincodeCodec, DecodeError, StaticRegistry};
use pg_debyte_macros::declare_decoder;
use serde::{Deserialize, Serialize};
use uuid::Uuid as CoreUuid;

pg_module_magic!();

#[derive(Debug, Deserialize, Serialize)]
struct MyRecord {
    id: u32,
    label: String,
}

const MY_TYPE_ID: CoreUuid = CoreUuid::from_bytes([0x22; 16]);
const MY_SCHEMA_VERSION: u16 = 1;
const MY_CODEC_ID: u16 = 1;
const MY_CODEC: BincodeCodec = BincodeCodec::new(MY_CODEC_ID, 32 * 1024 * 1024);

declare_decoder!(
    MY_DECODER,
    ty = MyRecord,
    type_id = MY_TYPE_ID,
    schema_version = MY_SCHEMA_VERSION,
    codec = MY_CODEC,
    codec_ty = BincodeCodec,
    actions = []
);

static REGISTRY: StaticRegistry = StaticRegistry::new(&[&MY_DECODER], &[]);

#[pg_guard]
pub unsafe extern "C-unwind" fn _PG_init() {
    pg_debyte_pgrx::init_gucs();
    pg_debyte_pgrx::set_registry(&REGISTRY);
}

#[pg_extern]
fn bytea_to_json_auto(data: Vec<u8>) -> Result<JsonB, DecodeError> {
    let limits = pg_debyte_pgrx::limits();
    let value = pg_debyte_pgrx::decode_auto(&data, &limits)?;
    Ok(JsonB(value))
}
```

`src/bin/demo_envelope.rs` (example of wrapping your data with an envelope; prints hex-encoded payload):

```rust
use hex::encode;
use pg_debyte_core::action::ActionSpec;
use pg_debyte_core::codec::BincodeCodec;
use pg_debyte_core::encode::encode_to_envelope;
use pg_debyte_core::registry::StaticRegistry;
use pg_debyte_core::types::{EncodeLimits, TypeKey};
use serde::Serialize;
use uuid::Uuid as CoreUuid;

#[derive(Debug, Serialize)]
struct MyRecord {
    id: u32,
    label: String,
}

fn main() {
    let record = MyRecord {
        id: 1,
        label: "demo".to_string(),
    };
    let key = TypeKey {
        type_id: CoreUuid::from_bytes([0x22; 16]),
        schema_version: 1,
    };
    let codec = BincodeCodec::new(1, 32 * 1024 * 1024);
    let limits = EncodeLimits::new(32 * 1024 * 1024);
    let registry = StaticRegistry::new(&[], &[]);
    let actions: Vec<ActionSpec> = Vec::new();

    let envelope = encode_to_envelope(&record, &codec, key, &actions, &registry, &limits)
        .expect("encode envelope");
    println!("{}", encode(envelope));
}
```

Usage:

```bash
cargo run --bin demo_envelope
```

```sql
SELECT bytea_to_json_auto(decode('<hex-encoded-envelope>', 'hex'));
```

## Example usage (PG17)

Build and install the example extension:

```bash
cargo pgrx init --pg17 /path/to/pg17
cargo pgrx install -p pg_debyte_ext --features pg17 --sudo
```

Enable in Postgres:

```sql
CREATE EXTENSION pg_debyte_ext;
```

Generate a demo payload hex:

```bash
# run the helper binary
cargo run -p pg_debyte_tools --bin demo_payload
```

Decode in SQL (raw payload, no envelope):

```sql
SELECT bytea_to_json_by_id(
  decode('<hex-encoded-payload>', 'hex'),
  '11111111-1111-1111-1111-111111111111'::uuid,
  1::smallint
);
```

Generate a demo payload hex for a known schema:

```bash
cargo run -p pg_debyte_tools --bin demo_second_payload
```

Decode in SQL (known schema, per-type function):

```sql
SELECT bytea_to_json_demo_record_second(decode('<hex-encoded-payload>', 'hex'));
```

Generate a demo envelope hex:

```bash
#run the helper binary
cargo run -p pg_debyte_tools --bin demo_envelope
```

Decode in SQL (auto envelope):

```sql
SELECT bytea_to_json_auto(decode('<hex-encoded-envelope>', 'hex'));
```

Generate a full SQL example for auto envelope:

```bash
cargo run -p pg_debyte_tools --bin demo_auto_sql
```

## Running pg tests in Docker

If host permissions make `cargo pgrx test` difficult, use the Docker runner:

```bash
./scripts/docker-ci-test-pg-extension.sh
```
